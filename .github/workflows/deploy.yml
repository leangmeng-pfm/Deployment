name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to deploy'
        required: true
        default: 'main'
        type: choice
        options:
          - main
          - develop
          - staging
          - feature/demo
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development
      force_deploy:
        description: 'Skip tests (emergency only)'
        required: false
        type: boolean
        default: false

env:
  NODE_VERSION: '18'
  IMAGE_NAME: nextjs-app
  REGISTRY: ghcr.io
  DEPLOY_BRANCH: ${{ github.event.inputs.branch || github.ref_name }}
  DEPLOY_ENV: ${{ github.event.inputs.environment || 'production' }}

jobs:
  # Test Job
  test:
    name: üß™ Test Application
    runs-on: ubuntu-latest
    if: github.event.inputs.force_deploy != 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ env.DEPLOY_BRANCH }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run linter
        run: npm run lint
      
      - name: Run tests
        run: npm run test:ci
      
      - name: Test build
        run: npm run build

#   # Build Docker Image
#   build:
#     name: üê≥ Build Docker Image  
#     needs: test
#     runs-on: ubuntu-latest
#     if: always() && (needs.test.result == 'success' || github.event.inputs.force_deploy == 'true')
    
#     steps:
#       - name: Checkout specific branch
#         uses: actions/checkout@v4
#         with:
#           ref: ${{ env.DEPLOY_BRANCH }}
      
#       - name: Set up Docker Buildx
#         uses: docker/setup-buildx-action@v3
      
#       - name: Login to GitHub Container Registry
#         uses: docker/login-action@v3
#         with:
#           registry: ${{ env.REGISTRY }}
#           username: ${{ github.actor }}
#           password: ${{ secrets.GITHUB_TOKEN }}
      
#       - name: Extract metadata
#         id: meta
#         uses: docker/metadata-action@v5
#         with:
#           images: ${{ env.REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}
#           tags: |
#             type=sha,prefix=${{ env.DEPLOY_BRANCH }}-
#             type=raw,value=${{ env.DEPLOY_ENV }}-latest
#             type=raw,value=latest,enable=${{ env.DEPLOY_BRANCH == 'main' && env.DEPLOY_ENV == 'production' }}
      
#       - name: Build and push Docker image
#         uses: docker/build-push-action@v5
#         with:
#           context: .
#           platforms: linux/amd64
#           push: true
#           tags: ${{ steps.meta.outputs.tags }}
#           labels: ${{ steps.meta.outputs.labels }}
#           cache-from: type=gha
#           cache-to: type=gha,mode=max

#   # Deploy to Server
#   deploy:
#     name: üöÄ Deploy to ${{ github.event.inputs.environment || 'Production' }}
#     needs: build
#     runs-on: ubuntu-latest
#     environment: 
#       name: ${{ github.event.inputs.environment || 'production' }}
#       url: http://${{ vars.SERVER_IP || secrets.SERVER_HOST }}:${{ github.event.inputs.environment == 'staging' && '3001' || github.event.inputs.environment == 'development' && '3002' || '3000' }}
    
#     steps:
#       - name: Checkout specific branch
#         uses: actions/checkout@v4
#         with:
#           ref: ${{ env.DEPLOY_BRANCH }}
      
#       - name: Setup SSH
#         run: |
#           mkdir -p ~/.ssh
#           echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
#           chmod 600 ~/.ssh/id_rsa
#           ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
          
#           # Test SSH connection
#           ssh -i ~/.ssh/id_rsa -o ConnectTimeout=10 ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "echo '‚úÖ SSH connection successful'"
      
#       - name: Prepare deployment configuration
#         run: |
#           # Set environment-specific variables
#           case "${{ env.DEPLOY_ENV }}" in
#             production)
#               echo "APP_PORT=3000" >> deployment.env
#               echo "REPLICAS=2" >> deployment.env
#               echo "NODE_ENV=production" >> deployment.env
#               ;;
#             staging)  
#               echo "APP_PORT=3001" >> deployment.env
#               echo "REPLICAS=1" >> deployment.env
#               echo "NODE_ENV=staging" >> deployment.env
#               ;;
#             development)
#               echo "APP_PORT=3002" >> deployment.env
#               echo "REPLICAS=1" >> deployment.env
#               echo "NODE_ENV=development" >> deployment.env
#               ;;
#           esac
          
#           # Add common variables
#           echo "DEPLOY_ENV=${{ env.DEPLOY_ENV }}" >> deployment.env
#           echo "DEPLOY_BRANCH=${{ env.DEPLOY_BRANCH }}" >> deployment.env
#           echo "GITHUB_REPOSITORY=${{ github.repository }}" >> deployment.env
#           echo "IMAGE_TAG=${{ env.DEPLOY_ENV }}-latest" >> deployment.env
          
#           echo "üìã Deployment Configuration:"
#           cat deployment.env
      
#       - name: Deploy Application
#         run: |
#           # Copy files to server
#           scp -i ~/.ssh/id_rsa docker-compose.yml ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:~/docker-compose-${{ env.DEPLOY_ENV }}.yml
#           scp -i ~/.ssh/id_rsa deployment.env ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:~/deployment-${{ env.DEPLOY_ENV }}.env
          
#           # Execute deployment
#           ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'DEPLOY_EOF'
#             set -e
            
#             # Load environment variables
#             source deployment-${{ env.DEPLOY_ENV }}.env
#             export $(grep -v '^#' deployment-${{ env.DEPLOY_ENV }}.env | xargs)
            
#             echo "üîê Logging into container registry..."
#             echo ${{ secrets.GITHUB_TOKEN }} | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
            
#             # Set image variables
#             STACK_NAME="nextjs-$DEPLOY_ENV"
#             SHA_IMAGE="${{ env.REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}:${{ env.DEPLOY_BRANCH }}-${{ github.sha }}"
#             TARGET_IMAGE="${{ env.REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}:${{ env.DEPLOY_ENV }}-latest"
            
#             echo "üîÑ Pulling image: $SHA_IMAGE"
#             docker pull $SHA_IMAGE
            
#             echo "üè∑Ô∏è Tagging as: $TARGET_IMAGE"
#             docker tag $SHA_IMAGE $TARGET_IMAGE
#             docker push $TARGET_IMAGE
            
#             echo "üöÄ Deploying stack: $STACK_NAME"
#             docker stack deploy -c docker-compose-$DEPLOY_ENV.yml $STACK_NAME --with-registry-auth
            
#             echo "‚è≥ Waiting for deployment..."
#             sleep 45
            
#             # Health check loop
#             for i in {1..10}; do
#               echo "Health check $i/10 for $DEPLOY_ENV environment..."
              
#               SERVICE_NAME="${STACK_NAME}_nextjs-app"
              
#               if ! docker service ls --format "{{.Name}}" | grep -q "$SERVICE_NAME"; then
#                 echo "‚ö†Ô∏è Service not found, waiting..."
#                 sleep 15
#                 continue
#               fi
              
#               RUNNING=$(docker service ps $SERVICE_NAME --filter "desired-state=running" --format "{{.CurrentState}}" 2>/dev/null | grep -c "Running" || echo "0")
#               DESIRED=$(docker service inspect $SERVICE_NAME --format "{{.Spec.Mode.Replicated.Replicas}}" 2>/dev/null || echo "1")
              
#               echo "Status: $RUNNING/$DESIRED replicas running"
              
#               if [ "$RUNNING" -eq "$DESIRED" ] && [ "$RUNNING" -gt "0" ]; then
#                 echo "‚úÖ Deployment SUCCESS for $DEPLOY_ENV!"
                
#                 echo "üåê Testing health endpoint..."
#                 sleep 10
                
#                 if curl -f -s http://localhost:$APP_PORT/api/health > /dev/null; then
#                   echo "‚úÖ Health check passed!"
#                   echo "üéâ Deployment completed successfully!"
#                   echo "üîó Access: http://${{ vars.SERVER_IP || secrets.SERVER_HOST }}:$APP_PORT"
#                   exit 0
#                 else
#                   echo "‚ö†Ô∏è Health check failed but service is running"
#                   exit 0
#                 fi
#               fi
              
#               if [ $i -eq 10 ]; then
#                 echo "‚ùå Deployment timeout!"
#                 docker service ps $SERVICE_NAME --no-trunc
#                 docker service logs $SERVICE_NAME --tail 30
#                 exit 1
#               fi
              
#               sleep 15
#             done
#           DEPLOY_EOF
      
#       - name: Configure Nginx (Production Only)
#         if: env.DEPLOY_ENV == 'production' && vars.SERVER_IP
#         run: |
#           ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'NGINX_EOF'
#             echo "üîß Configuring Nginx for production..."
            
#             # Use domain name if available, otherwise use IP
#             if [ -n "${{ vars.DOMAIN_NAME }}" ]; then
#               SERVER_NAME="${{ vars.DOMAIN_NAME }}"
#             else
#               SERVER_NAME="${{ vars.SERVER_IP }}"
#             fi
            
#             # Create nginx config
#             sudo tee /etc/nginx/sites-available/nextjs-production > /dev/null << 'NGINX_CONFIG'
# server {
#     listen 80;
#     server_name $SERVER_NAME;

#     # Security headers
#     add_header X-Environment "production";
#     add_header X-Frame-Options "SAMEORIGIN";
#     add_header X-Content-Type-Options "nosniff";

#     location / {
#         proxy_pass http://localhost:3000;
#         proxy_http_version 1.1;
#         proxy_set_header Upgrade $http_upgrade;
#         proxy_set_header Connection 'upgrade';
#         proxy_set_header Host $host;
#         proxy_set_header X-Real-IP $remote_addr;
#         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
#         proxy_set_header X-Forwarded-Proto $scheme;
#         proxy_cache_bypass $http_upgrade;
#     }

#     # Health check
#     location /health {
#         proxy_pass http://localhost:3000/api/health;
#         access_log off;
#     }
# }
# NGINX_CONFIG
            
#             # Enable site
#             sudo ln -sf /etc/nginx/sites-available/nextjs-production /etc/nginx/sites-enabled/
#             sudo nginx -t && sudo systemctl reload nginx
            
#             echo "‚úÖ Nginx configured for production at: $SERVER_NAME"
#           NGINX_EOF
      
#       - name: Deployment Summary
#         run: |
#           APP_PORT=${{ env.DEPLOY_ENV == 'staging' && '3001' || env.DEPLOY_ENV == 'development' && '3002' || '3000' }}
          
#           echo "## üéâ Deployment Summary" >> $GITHUB_STEP_SUMMARY
#           echo "" >> $GITHUB_STEP_SUMMARY
#           echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
#           echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
#           echo "| üåø Branch | \`${{ env.DEPLOY_BRANCH }}\` |" >> $GITHUB_STEP_SUMMARY
#           echo "| üè† Environment | \`${{ env.DEPLOY_ENV }}\` |" >> $GITHUB_STEP_SUMMARY
#           echo "| üñ•Ô∏è Server | \`${{ secrets.SERVER_HOST }}\` |" >> $GITHUB_STEP_SUMMARY
#           echo "| üåê App URL | http://${{ vars.SERVER_IP || secrets.SERVER_HOST }}:$APP_PORT |" >> $GITHUB_STEP_SUMMARY
#           echo "| üíö Health Check | http://${{ vars.SERVER_IP || secrets.SERVER_HOST }}:$APP_PORT/api/health |" >> $GITHUB_STEP_SUMMARY
#           echo "| üë§ Deployed by | @${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
#           echo "| üìù Commit | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
#           echo "" >> $GITHUB_STEP_SUMMARY
#           echo "### üöÄ Quick Links" >> $GITHUB_STEP_SUMMARY
#           echo "- **Application**: http://${{ vars.SERVER_IP || secrets.SERVER_HOST }}:$APP_PORT" >> $GITHUB_STEP_SUMMARY
#           echo "- **Health Check**: http://${{ vars.SERVER_IP || secrets.SERVER_HOST }}:$APP_PORT/api/health" >> $GITHUB_STEP_SUMMARY
      
#       - name: Cleanup
#         if: always()
#         run: rm -f ~/.ssh/id_rsa

#   # Cleanup old images
#   cleanup:
#     name: üßπ Cleanup Resources
#     needs: deploy
#     runs-on: ubuntu-latest
#     if: always()
    
#     steps:
#       - name: Cleanup server
#         run: |
#           mkdir -p ~/.ssh
#           echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
#           chmod 600 ~/.ssh/id_rsa
#           ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
          
#           ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'CLEANUP_EOF'
#             echo "üßπ Cleaning up old resources..."
            
#             # Remove old images (keep recent ones)
#             docker image prune -af --filter "until=168h"
            
#             # Remove unused volumes and networks
#             docker volume prune -f
#             docker network prune -f
            
#             # Show current status
#             echo "üìä Current Docker usage:"
#             docker system df
            
#             echo "üèóÔ∏è Active stacks:"
#             docker stack ls
            
#             echo "‚úÖ Cleanup completed"
#           CLEANUP_EOF
          
#           rm -f ~/.ssh/id_rsa